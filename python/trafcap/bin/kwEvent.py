# kwEvent.py
# Classes to receive data from an event stream and update mongo
import subprocess
import time
import trafcap
from datetime import datetime
import traceback
import string
from bson import binary, ObjectId
import binascii
import yaml
import sys
import random

#collection_info = [['ids_eventInfo',    ''],    # tm
#                   ['ids_captureInfo',    ''],  # tbm, tem 
#                   ['ids_eventCount',  ''],     # sbm, sem
#                   ['ids_captureCount',  ''],   # sbm, sem
#                   ['ids_eventGroups',  ''],    # tbm, tem
#                   ['ids_captureGroups',  ''],  # tbm, tem
#                   ['ids_eventGroups2',  ''],   # tbm, tem
#                   ['ids_captureGroups2', '']]  # tbm, tem

class KwEvent(object):
    """
    Parent class for handling non-IP packets 
    """
    def __init__(self):
        return

    @classmethod
    def parse(pc, pkt):
        print 'Override KwEvent.parse in subclass'
        return

    def initializeCaptureInfo(pc):
        print 'Override KwEvent.initializeCaptureInfo in subclass'
        return

    @classmethod
    def initializeCaptureCount(pc):
        print 'Override KwEvent.initializeCaptureCount in subclass'
        return

class SuricataEvent(KwEvent):
    """
    For handling events generated by Suricata
    """
    def __init__(self):
        return

    @classmethod
    def initStream(pc, action):
        proc = subprocess.call(['/etc/init.d/suricata', 
                                action],
                                bufsize=-1, stdout=subprocess.PIPE)
        return

    @classmethod
    def getSuricataConfigFilename(pc):
        config_file = None
        proc = subprocess.Popen(['ps', 'ax', '-o', 'cmd'], 
                                  bufsize=-1, stdout=subprocess.PIPE)
        output = proc.communicate()
        line = ''
        try:
            for line in output[0].split('\n'):
                if 'suricata' in line:
                    command_and_opts = line.split()
                    # If suricata is the command, look at opts
                    if 'suricata' in command_and_opts[0]:
                        dash_c_offset = command_and_opts.index('-c')
                        config_file = command_and_opts[dash_c_offset+1]
                        break
        except Exception, e:
            #print 'line: ', line
            #print 'output: ', output
            print 'Looking for Suricata instance...'
        return config_file 

    @classmethod
    def getSuricataClassificationFilename(pc, config_file):
        try:
            stream = open(config_file, 'r')
            config_info = yaml.load(stream)
            stream.close() 
        except Exception, e:
            print e
            print 'Error reading ', config_file 
        return config_info['classification-file']

    @classmethod
    def getSuricataClassifications(pc, filename):
        try:
            stream = open(filename, 'r')
            line = stream.readline()
            class_config_dict = {}
            while line:
                if line.startswith('config classification'):
                    prefix, content = line.split(':')
                    name, description, priority = content.split(',')
                    class_config_dict[description] = [name.strip(), \
                                                      description.strip(),\
                                                      priority.strip()]
                line = stream.readline()
        except Exception, e:
            print 'Error getting Suricata classifications from: ', filename       
        return class_config_dict

    @classmethod
    def saveEventInfo(pc, container, data):
        try:
            _id = container.db[container.info_collection].insert(data)
        except Exception, e:
            trafcap.logException(e) 

        return _id

class HttpEvent(SuricataEvent):
    """
    For handling HTTP events 
    """
    def __init__(self):
        return

    #   Sample HTTP extended info from Suricata
    #
    # 06/11/2013-12:38:54.963143 upload.wikimedia.org [**] 
    # /math/f/d/c/fdcdf9827923d0125c5d05d49be499fc.png [**] 
    # Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 ...  [**] 
    # http://en.wikipedia.org/wiki/Poynting%E2%80%93Robertson_effect [**] 
    # GET [**] HTTP/1.1 [**] 200 [**] 3366 bytes [**] 
    # 192.168.168.17:36431 -> 208.80.154.235:80

    @classmethod
    def parse(pc, event):
        key = (); data = {}
        time_and_host, path_and_args, user_agent, referer, method, proto, \
             ret_code, num_bytes_and_text, src_dst = event.split('[**]')

        # 06/12/2013-11:15:59.594889 go.disqus.com 
        #    Site name might be:  <hostname unknown>
        raw_time = time_and_host[0:26].strip()
        host = time_and_host[27:].strip()

        event_time, event_msec = raw_time.split('.')
        t = int(time.mktime(time.strptime(event_time, '%m/%d/%Y-%H:%M:%S')))
        value = float(str(t) + '.' + event_msec)
        data['t'] = value
        data['tm'] = trafcap.secondsToMinute(value)
        data['host'] = host 
       
        try:
            path, args = path_and_args.strip().split('?',1)
        except ValueError:
            path = path_and_args.strip()
            args = ''
        data['path'] = path

        # If so configured, save args field 
        if trafcap.http_save_url_args:
            data['args'] = args

        # If so configured, save entire referrer field (including args)
        if trafcap.http_save_url_args:
            data['ref'] = referer.strip()
        else:
            # trim referrer field
            try:
                ref_base, ref_args = referer.strip().split('?',1)
            except ValueError:
                ref_base = referer
            data['ref'] = ref_base

        data['ua'] = user_agent.strip()
        data['meth'] = method.strip()
        data['proto'] = proto.strip()
        data['rc'] = trafcap.stringToDigit(ret_code.strip())

        num_bytes, some_text = num_bytes_and_text.strip().split(' ') 
        data['bytes'] = int(num_bytes)

        # from_to
        #   192.168.168.17:46035 -> 72.21.91.121:80
        src_and_port, dst_and_port = src_dst.strip().split('->') 
        src, src_port = src_and_port.strip().split(':')
        dst, dst_port = dst_and_port.strip().split(':')
        data['src'] = src
        data['src_port'] = trafcap.stringToDigit(src_port)
        data['dst'] = dst 
        data['dst_port'] = trafcap.stringToDigit(dst_port)

        return key, data

    @classmethod
    def saveEventInfo(pc, container, data):

        if not trafcap.options.quiet:
            print data['t'],data['src'],data['dst'],data['host'],data['path']

        data['event_type'] = 'SURICATA_HTTP'

        data['src'] = trafcap.stringToInt(data['src'])
        data['dst'] = trafcap.stringToInt(data['dst'])
 
        data['__v'] = 0

        t_int, t_dec = ("%.6f" % data['t']).split('.')
        a_id_sec = hex(int(t_int))[2:]                  # 8 digits
        a_id_dec = t_dec                                # 6 digits
        a_id_rand = str(random.randint(1,999999999) + \
                        1000000000)                 # 10 digits
        a_id = a_id_sec + a_id_dec + a_id_rand   
        data['_id'] = ObjectId(a_id)

        if trafcap.options.mongo:
            _id = SuricataEvent.saveEventInfo(container, data)
            #print _id.generation_time, \
            #      datetime.fromtimestamp(data['t'])

        return

class IdsEvent(SuricataEvent):
    """
    For handling IDS events 
    """
    def __init__(self):
        return

    # Legend for how packet data is stored in Info dictionaries
    i_src=0; i_dst=1
    i_tb=2; i_te=3; i_events=4
    i_sid=5
    i_ldwt=6      # last_db_write_time
    i_csldw=7     # changed_since_last_db_write
    i_id=8

    # Legend for how data is stored in the Event Count dictionary 
    # and the Capture Count dictionary 
    c_key=0; c_src=0; c_dst=1; c_sid=2
    c_sb=1; c_se=2
    c_array=3; c_offset=0; c_count=1
    c_events=4
    c_msg=5
    c_short_class=6
    c_prio=7
    c_ldwt=8      # last_db_write_time
    c_csldw=9     # changed_since_last_db_write

    # Legend for Group dictionary data structure:
    g_e_type=0     # made first similar to lpj - not sure if needed yet
    g_src=1; 
    g_dst=2; 
    g_sid=3
    g_tbm=4; g_tem=5
    g_e=6; g_offset=0; g_cnt=1
    g_e_cnt=7 
    g_msg=8
    g_short_class=9
    g_prio=10
    g_id=11

    # src_ip, dst_ip, sig_id 
    capture_dict_key = ('0', '0', 0)

    @classmethod
    def initializeCaptureInfo(pc):
        current_time = time.time()         # float
        current_seq = int(current_time)    # int
        
        info_list = ['0','0',0,0,0,0,0,False, None] 
        # Set begin time 
        info_list[pc.i_tb] = current_time 
        return info_list

    @classmethod
    def initializeCaptureCount(pc):
        # Trying to remember why this is cast to a list
        key = list(pc.capture_dict_key)
        capture_count_list = [key, 0,0, [[0,0]], 0, '', '', 0, 0, False]
        return capture_count_list

    @classmethod
    def buildCountDoc(pc, a_count):
        event_count = {"src":trafcap.stringToInt(a_count[pc.c_key][pc.c_src]),
                       "dst":trafcap.stringToInt(a_count[pc.c_key][pc.c_dst]),
                       "sid":a_count[pc.c_key][pc.c_sid],
                       "sb":a_count[pc.c_sb],
                       "se":a_count[pc.c_se],
                       "sbm":trafcap.secondsToMinute(a_count[pc.c_sb]),
                       "sem":trafcap.secondsToMinute(a_count[pc.c_se]),
                       "msg":a_count[pc.c_msg],
                       "prio":a_count[pc.c_prio],
                       "short_class":a_count[pc.c_short_class],
                       "e_cnt":a_count[pc.c_events],
                       "e":a_count[pc.c_array]}
        return event_count 

    # Only build capture info - no dictionary for event info
    @classmethod
    def buildInfoDoc(pc, a_info):
        tbm=trafcap.secondsToMinute(a_info[pc.i_tb])
        tem=trafcap.secondsToMinute(a_info[pc.i_te])
        info_doc = {"src":trafcap.stringToInt(a_info[pc.i_src]),
                    "dst":trafcap.stringToInt(a_info[pc.i_dst]),
                    "sid":a_info[pc.i_sid],
                    "tbm":tbm,
                    "tem":tem,
                    "tdm":tem-tbm,
                    "tb":a_info[pc.i_tb],
                    "te":a_info[pc.i_te],
                    "events":a_info[pc.i_events]}
        return info_doc

    @classmethod
    def buildGroupsDoc(pc, a_group):

        group_events = []
        for item in a_group[pc.g_e]:
            if item[pc.g_cnt] != 0:
                group_events.append(item)


        group_data = {"src":a_group[pc.g_src],
                      "dst":a_group[pc.g_dst],
                      "sid":a_group[pc.g_sid],
                      "tbm":a_group[pc.g_tbm],
                      "tem":a_group[pc.g_tem],
                      "e_cnt":a_group[pc.g_e_cnt],
                      "msg":a_group[pc.g_msg],
                      "short_class":a_group[pc.g_short_class],
                      "prio":a_group[pc.g_prio],
                      "e":group_events}
        return group_data

    @classmethod
    def getGroupKey(pc, a_count):
        return (a_count['src'], a_count['dst'], a_count['sid'])

    @classmethod
    def updateGroupsDict(pc, a_count, chunck_size, doc_win_start):
        tmp_array = []
        for a_index in range(0, 90, 1):
            tmp_array.append([a_index*chunck_size, 0])

        a_group =[0, a_count['src'], a_count['dst'], a_count['sid'], 
                  doc_win_start, trafcap.secondsToMinute(a_count['se']),
                  tmp_array, 0, a_count['msg'], a_count['short_class'],
                  a_count['prio'],None]
        return a_group

    #  Suricata Full Alert Format:
    #
    #TIME:              06/05/2013-04:54:19.273641
    #SRC IP:            192.168.168.17
    #DST IP:            255.255.255.255
    #PROTO:             17
    #SRC PORT:          17500
    #   other fields here..........
    #PACKET: 
    # 0000  FF FF FF FF FF FF 1C C1  DE 61 C4 2D 08 00 45 00   ........ .a.-..E.
    # 0000  FF FF FF                                           ...
    #   other fields here..........

    @classmethod
    def parse(pc, alert):
        key = (); data = {}
         
        # Alert ingested from event stream
        prev_name = ''
        lines = alert.split('\n')

        have_alert = False
        have_stream = False

        for line in lines:
            if len(line) == 0:
                #print "-----"
                continue
            if prev_name == 'packet' or prev_name == 'payload' \
                                     or prev_name == 'stream_data':

                if line[0] == ' ':
                    hex_line = line[7:55].translate( None, 
                                                     string.whitespace )
                    hex_data = hex_data + hex_line
                    data[prev_name] = hex_data 
                    continue

            # Extract name-value pairs 
            colon_loc = line.find(':')
            name = line[0:colon_loc].lower().replace(' ', '_')
            name = name.rstrip('_[00]')
            value = line[colon_loc+1:].strip()

            if name.startswith('alert_'): name = name[6:]

            # for now, ignore multiple alerts and multiple streams
            if have_alert and name == 'msg': break
            if have_stream and name == 'stream_data_len': break

            if name == 'msg': have_alert = True
            elif name == 'stream_data_len': have_stream = True
            elif name == 'time':
                # time entry format: 06/03/2013-07:49:54.025717
                event_time, event_msec = value.split('.')
                t = int(time.mktime(time.strptime(event_time,
                                                  '%m/%d/%Y-%H:%M:%S')))
                value = float(str(t) + '.' + event_msec)
                name = 't'
                data['tm'] = trafcap.secondsToMinute(value)
              
            elif name == 'flow_start_ts':
                # time entry format: 06/03/2013-07:49:54.025717
                event_time, event_msec = value.split('.')
                t = int(time.mktime(time.strptime(event_time,
                                                  '%m/%d/%Y-%H:%M:%S')))
                value = float(str(t) + '.' + event_msec)
                data[name] = trafcap.secondsToMinute(value)
            
            elif name == 'src_ip': name = 'src'
            elif name == 'dst_ip': name = 'dst'
            else: pass

            # change numbers from strings to ints
            if type(value) is str: 
                if value.isdigit(): 
                    value = int(value)

            data[name] = value 

            prev_name = name
            hex_data = '' 

            
        # populate short_class field
        try:
            short_class=trafcap.classification_config_dict[data['class']][0]
            data['short_class'] = short_class
        except KeyError:
            data['short_class'] = 'not-found'

        key = (data['src'], data['dst'], data['sid'])

        return key, data

    @classmethod
    def saveEventInfo(pc, container, data):
        """
           "event_type" : "UNIFIED2_IDS_EVENT_LEGACY",
           "event_info" : {.....},
           "packet" : BinData 
           "payload" : BinData 
           "stream_data" : BinData 
           "sensor" : {
               "id" : 0,
               "interface" : "bond0",
               "name" : "sentry"
           },
           "event_id" : 2802
           "_id" : ObjectId("51a80a8761dcfeb10b000001"),
           "__v" : 0
        """

        data['event_type'] = 'SURICATA_FULL_ALERT'

        # convert hex strings into binary data
        for name in ['packet', 'payload', 'stream_data']:
            try:
                data[name] = binary.Binary(binascii.a2b_hex(data[name]))
            except KeyError:
                continue
   
        sensor = {}
        sensor['id'] = 0
        sensor['interface'] = trafcap.sniff_interface 
        sensor['name'] = 'sentry'
        data['sensor'] = sensor
  
        data['__v'] = 0

        data['src'] = trafcap.stringToInt(data['src'])
        data['dst'] = trafcap.stringToInt(data['dst'])
 
        if trafcap.options.mongo:
            SuricataEvent.saveEventInfo(container, data)

        return
